#! /usr/bin/ruby

# # Intro
#
# This script is meant for people who often need to send patchs using
# `git send-email`. It’s an enhanced shortcut for `git format-patch` followed
# by `git send-email`. Its name comes from both commands:
#     git [s]end-email [f]ormat-patch
# Plus it’s easy to type with one hand.
#
# # Install
#
# 1. copy this script in a PATH directory and set it executable (chmod +x)
# 2. configure the target emails:
#       git config sf.emails oneemail@domain.com,another@foo.bar
# 3. optionally configure your SMTP server:
#       git config sendemail.smtpserver <your SMTP server>
# 
# # Usage
#
#   git sf [<revision>]
#
# This is the equivalent of `git format-patch <revision>`, then
# `git send-email` for each patch. If not provided, `<revision>` will be
# `HEAD^`.
# It’ll prompt you for each patch. This allows you to select which patchs you
# want to send. All patchs are removed after being sent.
#
# # License
#
# MIT.

# TODO use Thunderbird to send patchs as attachments when they don't pass in
# with normal way
# https://developer.mozilla.org/en-US/docs/Mozilla/Command_Line_Options#-compose_message_options

EMAILS = `git config sf.emails`.split(',').map(&:strip)

if EMAILS.empty?
  puts "No email found. Use 'git config sf.emails a@a.com,b@b.com'"
  exit 1
end

trap('INT') { exit 1 }

def cmd(s)
  puts "--> #{s}"
  `#{s}`
end

def select_email
  puts 'Send email to:'
  EMAILS.each_with_index { |e,i| puts "#{i}: #{e}" }
  print "Choice: [0] "
  choice = STDIN.readline.chomp.strip
  choice = 0 if choice.empty?
  e = EMAILS[choice.to_i]
  return e if e
  puts "Wrong choice."
  select_email
end

what = ARGV.empty? ? 'HEAD^' : ARGV * ' '
patches = cmd("git format-patch #{what}").split(/\n+/)

if patches.size == 0
  puts "There's no patch to send."
  exit 0
end

addr = select_email
patches.each do |p|
  print "Send #{p}? [y] "
  if ['', 'y'].include? STDIN.readline.chomp.strip
    cmd "git send-email --confirm=never --8bit-encoding=UTF-8 --to #{addr} #{p}"
  end
  cmd "rm #{p}"
end
